# Architecture Decision Records (ADR)

Документ содержит ключевые архитектурные и технические решения, принятые при разработке проекта.

---

## ADR-001: Выбор Python 3.11+ в качестве основного языка

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходимо выбрать язык программирования для реализации Telegram-бота с LLM.

### Решение
Использовать Python 3.11+ (версию, установленную на компьютере разработчика).

### Обоснование
- Богатая экосистема библиотек для работы с Telegram и LLM
- Простота и читаемость кода (принцип KISS)
- Отличная поддержка асинхронного программирования
- Быстрая разработка MVP

### Последствия
- Положительные: быстрая разработка, много готовых решений
- Отрицательные: производительность ниже, чем у компилируемых языков (но достаточна для MVP)

---

## ADR-002: Использование uv для управления зависимостями

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходим инструмент для управления зависимостями и виртуальным окружением.

### Решение
Использовать uv вместо pip/poetry/pipenv.

### Обоснование
- Современный и быстрый менеджер пакетов
- Простота использования
- Совместимость с pyproject.toml

### Последствия
- Положительные: скорость установки пакетов, современный подход
- Отрицательные: менее распространен, чем pip/poetry

---

## ADR-003: Aiogram с polling для Telegram Bot API

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Нужен способ интеграции с Telegram Bot API.

### Решение
Использовать библиотеку aiogram 3.x с методом polling.

### Обоснование
- Aiogram - современный асинхронный фреймворк для Telegram
- Polling проще настроить, чем webhook (не требует HTTPS/домена)
- Достаточно для MVP и тестирования

### Последствия
- Положительные: простота настройки, не нужен сервер с HTTPS
- Отрицательные: polling менее эффективен, чем webhook (но для MVP приемлемо)

---

## ADR-004: OpenAI client + OpenRouter для работы с LLM

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходим способ взаимодействия с различными LLM моделями.

### Решение
Использовать официальный клиент openai с кастомным base_url, указывающим на OpenRouter API.

### Обоснование
- OpenRouter предоставляет единый API для множества моделей
- Официальный клиент openai стабилен и хорошо документирован
- Простое переключение между моделями через конфигурацию

### Последствия
- Положительные: гибкость выбора моделей, единый интерфейс
- Отрицательные: зависимость от внешнего сервиса

---

## ADR-005: Простой dict для конфигурации

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходима структура для хранения конфигурации приложения.

### Решение
Использовать обычный dict вместо dataclass или Pydantic.

### Обоснование
- Максимальная простота (принцип KISS)
- Достаточно для MVP
- Не требует дополнительных зависимостей

### Последствия
- Положительные: простота реализации
- Отрицательные: нет валидации типов на уровне языка (но приемлемо для MVP)

---

## ADR-006: Хранение истории диалогов в памяти

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходимо хранить историю диалогов для контекста LLM.

### Решение
Хранить историю в памяти процесса (dict), без персистентности.

### Обоснование
- Простота реализации
- Достаточно для MVP и тестирования
- Нет необходимости в БД на этапе проверки концепции

### Последствия
- Положительные: максимальная простота, быстродействие
- Отрицательные: история теряется при перезапуске бота

---

## ADR-007: Контекст 20 последних сообщений

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходимо определить размер контекста для LLM.

### Решение
Хранить и передавать последние 20 сообщений (10 пар вопрос-ответ).

### Обоснование
- Баланс между контекстом и расходом токенов
- Достаточно для поддержания связного диалога
- Не перегружает API запросы

### Последствия
- Положительные: оптимальный баланс контекста и стоимости
- Отрицательные: длинные диалоги могут терять ранний контекст

---

## ADR-008: Асинхронный LLM клиент

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Выбор между синхронным и асинхронным клиентом для LLM.

### Решение
Использовать асинхронный OpenAI клиент.

### Обоснование
- Aiogram работает асинхронно
- Лучшая производительность при одновременных запросах
- Не блокирует обработку других сообщений

### Последствия
- Положительные: эффективное использование ресурсов
- Отрицательные: чуть более сложная реализация (но aiogram уже async)

---

## ADR-009: Параметры LLM модели по умолчанию

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Нужно определить параметры для вызова LLM (temperature, max_tokens).

### Решение
Использовать параметры по умолчанию, не переопределять их.

### Обоснование
- Простота (принцип KISS)
- Параметры по умолчанию оптимальны для большинства случаев
- Можно настроить позже при необходимости

### Последствия
- Положительные: меньше кода, меньше решений
- Отрицательные: нет тонкой настройки поведения LLM

---

## ADR-010: Базовые команды бота

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходимо определить набор команд для управления ботом.

### Решение
Реализовать команды: `/start`, `/help`, `/reset`, `/status`.

### Обоснование
- Минимально необходимый набор для MVP
- `/start` и `/help` - стандарт для Telegram ботов
- `/reset` - для очистки контекста
- `/status` - для проверки работоспособности

### Последствия
- Положительные: простота, покрывает основные сценарии
- Отрицательные: ограниченный функционал (но достаточен для MVP)

---

## ADR-011: Индикатор "печатает..."

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Нужно обеспечить обратную связь во время ожидания ответа LLM.

### Решение
Показывать статус "печатает..." (typing action) во время обработки запроса.

### Обоснование
- Улучшает пользовательский опыт
- Показывает, что бот работает
- Стандартная практика для чат-ботов

### Последствия
- Положительные: лучший UX, понимание что бот работает
- Отрицательные: минимальный дополнительный код

---

## ADR-012: Дружественные сообщения об ошибках

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходимо определить подход к обработке ошибок для пользователя.

### Решение
Показывать пользователям дружественные сообщения, технические детали логировать в файл.

### Обоснование
- Лучший пользовательский опыт
- Технические детали не понятны обычным пользователям
- Разработчик получает полную информацию через логи

### Последствия
- Положительные: профессиональный подход, хороший UX
- Отрицательные: нужно продумать тексты дружественных сообщений

---

## ADR-013: Конфигурация через .env файл

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходим способ конфигурирования приложения.

### Решение
Использовать .env файл с библиотекой python-dotenv.

### Обоснование
- Стандартный подход для Python проектов
- Простота использования
- Безопасность (секреты не в коде)
- Удобство для разработки и деплоя

### Последствия
- Положительные: простота, безопасность, стандартный подход
- Отрицательные: нужно создавать .env файл при развертывании

---

## ADR-014: Валидация конфигурации с предупреждениями

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Как обрабатывать отсутствие обязательных параметров конфигурации.

### Решение
Выводить предупреждения при отсутствии параметров, использовать значения по умолчанию где возможно.

### Обоснование
- Более гибкий подход, чем падение с ошибкой
- Позволяет запустить бота даже с неполной конфигурацией
- Разработчик видит что не хватает через предупреждения

### Последствия
- Положительные: гибкость, удобство разработки
- Отрицательные: возможен запуск с некорректной конфигурацией

---

## ADR-015: Логирование в файл с деталями

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходимо определить подход к логированию сообщений пользователей.

### Решение
Логировать первые 200 символов сообщений + длину полного сообщения для MVP.

### Обоснование
- Легче отлаживать и анализировать проблемы
- Видно как пользователи взаимодействуют с ботом
- Для MVP приемлемо (продакшен потребует другого подхода)

### Последствия
- Положительные: простота отладки, понимание использования
- Отрицательные: вопросы приватности (требует пересмотра для продакшена)

---

## ADR-016: Логирование в файл и консоль

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Куда выводить логи приложения.

### Решение
Выводить логи одновременно в файл (logs/bot.log) и консоль.

### Обоснование
- Файл - для постоянного хранения и анализа
- Консоль - для мониторинга в реальном времени
- Стандартный подход для серверных приложений

### Последствия
- Положительные: удобство разработки и эксплуатации
- Отрицательные: немного больше кода настройки

---

## ADR-017: Ruff для линтинга и форматирования

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходим инструмент для контроля качества кода.

### Решение
Использовать ruff как единый инструмент для линтинга и форматирования.

### Обоснование
- Очень быстрый (написан на Rust)
- Заменяет flake8, black, isort одним инструментом
- Современный и активно развивающийся

### Последствия
- Положительные: скорость, простота (один инструмент)
- Отрицательные: относительно новый инструмент

---

## ADR-018: Отложить тесты до проверки концепции

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Писать ли тесты на этапе MVP.

### Решение
Отложить написание тестов до проверки концепции.

### Обоснование
- MVP фокусируется на проверке идеи
- Тесты требуют времени
- Код может сильно измениться после проверки концепции
- Принцип KISS для MVP

### Последствия
- Положительные: быстрая разработка MVP
- Отрицательные: больший риск багов, сложнее рефакторинг

---

## ADR-019: Docstrings для документации кода

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Как документировать код.

### Решение
Писать docstrings для классов и публичных методов.

### Обоснование
- Улучшает читаемость и понимание кода
- Помогает при разработке (IDE показывает документацию)
- Стандартная практика для Python

### Последствия
- Положительные: лучшая поддерживаемость кода
- Отрицательные: дополнительное время на написание

---

## ADR-020: Make для автоматизации команд

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Необходим инструмент для автоматизации рутинных команд.

### Решение
Использовать Makefile с командами для установки, запуска и линтинга.

### Обоснование
- Простой и универсальный инструмент
- Стандартизирует команды разработки
- Удобный интерфейс для типовых операций

### Последствия
- Положительные: упрощение работы, стандартизация
- Отрицательные: нужен make в системе (есть почти везде)

---

## ADR-021: Принцип "1 класс = 1 файл"

**Дата:** 2025-10-10  
**Статус:** Принято

### Контекст
Как организовывать код проекта.

### Решение
Строго следовать принципу: один класс в одном файле.

### Обоснование
- Улучшает навигацию по коду
- Упрощает поиск реализации
- Соответствует ООП принципам
- Четкая структура проекта

### Последствия
- Положительные: ясная структура, легко найти код
- Отрицательные: больше файлов (но это не проблема для MVP из 4 классов)

---

## Итого

Все решения приняты с фокусом на **простоту, скорость разработки MVP и проверку концепции**. Следуем принципам KISS и избегаем оверинжиниринга. После проверки идеи можем пересмотреть решения для продакшен-версии.

