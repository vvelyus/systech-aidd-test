---
alwaysApply: true
---
# Conventions - Правила разработки для Code Assistant

> Полное техническое видение проекта см. в @VISION.md

## Главные принципы

### KISS - Keep It Simple, Stupid
- Максимальная простота решений
- Никакого оверинжиниринга
- Никаких абстракций "на будущее"

### ООП - Один класс = Один файл
- Строго 1 класс в 1 файле
- Имя файла = имя класса (snake_case для файла, PascalCase для класса)

### Читаемость превыше всего
- Понятные имена переменных и функций
- Минимальная вложенность (максимум 2-3 уровня)
- Код должен быть самоочевидным

### SOLID принципы
- **S**ingle Responsibility: один класс - одна ответственность
- **O**pen/Closed: открыт для расширения, закрыт для модификации
- **L**iskov Substitution: подтипы должны заменять базовые типы
- **I**nterface Segregation: много специализированных интерфейсов
- **D**ependency Inversion: зависимость от абстракций, не от конкретики

### DRY - Don't Repeat Yourself
- Избегать дублирования кода
- Выносить повторяющуюся логику в функции/методы
- Использовать декораторы для повторяющихся паттернов

---

## Структура кода

### Организация файлов
```
src/
  ├── main.py           # Точка входа
  ├── bot.py            # TelegramBot класс
  ├── llm_client.py     # LLMClient класс
  ├── config.py         # Config класс (dataclass)
  ├── context_storage.py # ContextStorage Protocol + реализации
  ├── messages.py       # Текстовые константы бота
  └── logger.py         # Logger настройка

tests/
  ├── conftest.py       # Общие фикстуры
  ├── integration/      # Интеграционные тесты
  └── test_*.py         # Unit тесты
```

### Документация
- Docstrings для всех классов и публичных методов
- Формат Google Style (краткое описание + Args + Returns + Raises)
- Type hints для всех публичных методов

---

## Качество кода

### Type Hints (обязательно)
```python
from typing import Optional, List, Dict

async def get_response(self, user_message: str) -> str:
    """Получить ответ от LLM."""
    ...

def _add_to_context(
    self, user_id: int, role: str, content: str
) -> None:
    """Добавить сообщение в контекст."""
    ...
```

### Форматирование и линтинг

**Ruff (обязательные правила):**
```toml
[tool.ruff.lint]
select = [
    "E",   # pycodestyle errors
    "F",   # pyflakes
    "W",   # pycodestyle warnings
    "I",   # isort
    "N",   # pep8-naming
    "UP",  # pyupgrade
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "SIM", # flake8-simplify
    "RUF", # Ruff-specific rules
]
```

**Команды:**
- `make lint` - проверка кода
- `make format` - форматирование
- Длина строки: 100 символов

### Type Checking

**Mypy (strict mode):**
```toml
[tool.mypy]
python_version = "3.11"
strict = true
warn_unused_ignores = true
disallow_untyped_defs = true
```

**Команда:**
- `make type-check` - проверка типов

### CI Pipeline

**Обязательная проверка перед коммитом:**
```bash
make ci  # lint + format + type-check + test
```

Все проверки должны проходить без ошибок.

---

## Технические требования

### Асинхронность
- Весь код асинхронный (async/await)
- Aiogram и OpenAI клиент - асинхронные

### Стек технологий
- **Python 3.11+**
- **aiogram 3.x** для Telegram
- **openai** для работы с OpenRouter API
- **python-dotenv** для конфигурации
- **mypy** для type checking
- **ruff** для linting и formatting
- **pytest** для тестирования

### Конфигурация
- Все настройки через .env файл
- **Config как @dataclass(frozen=True)**
- Валидация обязательных полей с ConfigError
- Type hints для всех полей

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Config:
    """Конфигурация приложения."""
    telegram_token: str
    openrouter_api_key: str
    bot_name: str = "SysTech AI Assistant"
    # ...
```

### Логирование
- Использовать стандартный модуль logging
- Логировать в файл и консоль
- Уровни: INFO, WARNING, ERROR
- Формат: `%(asctime)s - %(name)s - %(levelname)s - %(message)s`

---

## Стиль кода

### Именование
- Файлы: `snake_case.py`
- Классы: `PascalCase`
- Функции/методы: `snake_case()`
- Константы: `UPPER_SNAKE_CASE`
- Приватные: `_leading_underscore`
- Type variables: `T`, `T_co`, `KT`, `VT`

### Обработка ошибок
- Технические ошибки логировать с stack trace
- Пользователю показывать дружественные сообщения
- Не использовать bare except
- Создавать custom exceptions при необходимости

```python
class ConfigError(Exception):
    """Ошибка конфигурации приложения."""
    pass
```

### Комментарии
- Код должен быть самодокументируемым
- Комментарии только для неочевидной логики
- Предпочитать понятные имена комментариям

---

## Тестирование

### Стандарты покрытия
- **Общее покрытие: >= 85%**
- **Новый код: >= 90%**
- **Критические модули: 100%**

### Структура тестов
```python
def test_method_name_scenario():
    """Test method_name with specific scenario."""
    # Arrange
    setup_data = ...
    
    # Act
    result = method_name(setup_data)
    
    # Assert
    assert result == expected_value
```

### Типы тестов
- **Unit тесты:** для всех публичных методов
- **Edge cases:** граничные условия
- **Error handling:** обработка ошибок
- **Integration:** критические пользовательские сценарии

### Фикстуры
- Общие фикстуры в `tests/conftest.py`
- DRY: избегать дублирования в тестах
- Понятные имена фикстур

### Команды
- `make test` - запуск всех тестов
- `make test-cov` - с coverage report
- Coverage должен быть >= 85%

---

## Лучшие практики Python

### Используй

✅ **List/Dict comprehensions** вместо циклов (где уместно)
✅ **Context managers** для управления ресурсами
✅ **Dataclasses** для data containers
✅ **Type hints** везде
✅ **Protocol** для duck typing
✅ **Enum** для константных наборов
✅ **pathlib** вместо os.path
✅ **f-strings** для форматирования строк

### Избегай

❌ Mutable default arguments
❌ Bare except
❌ Global variables
❌ `import *`
❌ Hardcoded strings (использовать константы)
❌ Deep nesting (max 2-3 уровня)
❌ God classes (> 500 строк)
❌ Long methods (> 50 строк)

### Пример хорошего кода

```python
from dataclasses import dataclass
from typing import Protocol, List

class ContextStorage(Protocol):
    """Протокол для хранилища контекста."""
    
    def add_message(self, user_id: int, role: str, content: str) -> None:
        """Добавить сообщение."""
        ...

@dataclass(frozen=True)
class Message:
    """Сообщение в контексте."""
    role: str
    content: str

class InMemoryContextStorage:
    """Хранилище контекста в памяти."""
    
    def __init__(self, max_messages: int = 20) -> None:
        """Инициализация хранилища."""
        self._storage: dict[int, List[Message]] = {}
        self._max_messages = max_messages
    
    def add_message(
        self, user_id: int, role: str, content: str
    ) -> None:
        """Добавить сообщение в контекст."""
        if user_id not in self._storage:
            self._storage[user_id] = []
        
        self._storage[user_id].append(Message(role, content))
        self._trim_context(user_id)
    
    def _trim_context(self, user_id: int) -> None:
        """Обрезать контекст до лимита."""
        if len(self._storage[user_id]) > self._max_messages:
            self._storage[user_id] = self._storage[user_id][
                -self._max_messages:
            ]
```

---

## Что НЕ делать

❌ Создавать абстракции для возможного будущего расширения  
❌ Помещать несколько классов в один файл  
❌ Использовать сложные паттерны проектирования без необходимости  
❌ Добавлять функционал "на всякий случай"  
❌ Писать синхронный код  
❌ Использовать глобальные переменные  
❌ Игнорировать docstrings  
❌ Игнорировать type hints  
❌ Коммитить код без прохождения `make ci`  
❌ Снижать test coverage  
❌ Игнорировать ошибки mypy/ruff

---

## Контрольный чек-лист перед генерацией кода

### Базовые требования
- [ ] Решение максимально простое (KISS)?
- [ ] Один класс в файле?
- [ ] Код асинхронный (async/await)?
- [ ] Есть docstrings (Google Style)?
- [ ] Понятные имена переменных?
- [ ] Вложенность не более 2-3 уровней?
- [ ] Есть логирование важных событий?
- [ ] Ошибки обрабатываются корректно?
- [ ] Нет лишнего функционала?

### Качество кода
- [ ] Type hints для всех публичных методов?
- [ ] Код пройдет `make lint` без ошибок?
- [ ] Код пройдет `make type-check` без ошибок?
- [ ] Есть тесты для нового кода?
- [ ] Coverage >= 85%?
- [ ] Нет дублирования кода (DRY)?
- [ ] Следует SOLID принципам?

### Перед коммитом
- [ ] `make ci` проходит без ошибок?
- [ ] Все тесты проходят?
- [ ] Документация обновлена?
- [ ] TASKLIST обновлен?

---

## 📚 Ресурсы

### Инструменты
- [Ruff](https://docs.astral.sh/ruff/) - линтер и форматтер
- [Mypy](https://mypy.readthedocs.io/) - type checker
- [Pytest](https://docs.pytest.org/) - тестирование

### Стиль кода
- [PEP 8](https://peps.python.org/pep-0008/) - Style Guide
- [PEP 484](https://peps.python.org/pep-0484/) - Type Hints
- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)

---

> **Помни:** Качество кода важно, но KISS превыше всего. Не усложняй ради "чистоты".

